/* 
 * UiPath.WebApi
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: V2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using PropertyChanged;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = UiPathEJC.Service.Rest.Client.SwaggerDateConverter;

namespace UiPathEJC.Service.Rest.Model
{
    /// <summary>
    /// Stores data sent when processing of an existing or a new item starts.
    /// </summary>
    [DataContract]
    [ImplementPropertyChanged]
    public partial class TransactionDataDto :  IEquatable<TransactionDataDto>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TransactionDataDto" /> class.
        /// </summary>
        /// <param name="Name">The name of the queue in which to search for the next item or in which to insert the item before marking it as InProgress and sending it to the robot..</param>
        /// <param name="RobotIdentifier">The unique key identifying the robot that sent the request..</param>
        /// <param name="SpecificContent">If not null a new item will be added to the queue with this content before being moved to InProgress state and returned to the robot for processing.  &lt;para /&gt;If null the next available item in the list will be moved to InProgress state and returned to the robot for processing..</param>
        /// <param name="DeferDate">The earliest date and time at which the item is available for processing. If empty the item can be processed as soon as possible..</param>
        /// <param name="DueDate">The latest date and time at which the item should be processed. If empty the item can be processed at any given time..</param>
        /// <param name="Reference">An optional, user-specified value for queue item identification..</param>
        public TransactionDataDto(string Name = default(string), Guid? RobotIdentifier = default(Guid?), Dictionary<string, Object> SpecificContent = default(Dictionary<string, Object>), DateTime? DeferDate = default(DateTime?), DateTime? DueDate = default(DateTime?), string Reference = default(string))
        {
            this.Name = Name;
            this.RobotIdentifier = RobotIdentifier;
            this.SpecificContent = SpecificContent;
            this.DeferDate = DeferDate;
            this.DueDate = DueDate;
            this.Reference = Reference;
        }
        
        /// <summary>
        /// The name of the queue in which to search for the next item or in which to insert the item before marking it as InProgress and sending it to the robot.
        /// </summary>
        /// <value>The name of the queue in which to search for the next item or in which to insert the item before marking it as InProgress and sending it to the robot.</value>
        [DataMember(Name="Name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// The unique key identifying the robot that sent the request.
        /// </summary>
        /// <value>The unique key identifying the robot that sent the request.</value>
        [DataMember(Name="RobotIdentifier", EmitDefaultValue=false)]
        public Guid? RobotIdentifier { get; set; }

        /// <summary>
        /// If not null a new item will be added to the queue with this content before being moved to InProgress state and returned to the robot for processing.  &lt;para /&gt;If null the next available item in the list will be moved to InProgress state and returned to the robot for processing.
        /// </summary>
        /// <value>If not null a new item will be added to the queue with this content before being moved to InProgress state and returned to the robot for processing.  &lt;para /&gt;If null the next available item in the list will be moved to InProgress state and returned to the robot for processing.</value>
        [DataMember(Name="SpecificContent", EmitDefaultValue=false)]
        public Dictionary<string, Object> SpecificContent { get; set; }

        /// <summary>
        /// The earliest date and time at which the item is available for processing. If empty the item can be processed as soon as possible.
        /// </summary>
        /// <value>The earliest date and time at which the item is available for processing. If empty the item can be processed as soon as possible.</value>
        [DataMember(Name="DeferDate", EmitDefaultValue=false)]
        public DateTime? DeferDate { get; set; }

        /// <summary>
        /// The latest date and time at which the item should be processed. If empty the item can be processed at any given time.
        /// </summary>
        /// <value>The latest date and time at which the item should be processed. If empty the item can be processed at any given time.</value>
        [DataMember(Name="DueDate", EmitDefaultValue=false)]
        public DateTime? DueDate { get; set; }

        /// <summary>
        /// An optional, user-specified value for queue item identification.
        /// </summary>
        /// <value>An optional, user-specified value for queue item identification.</value>
        [DataMember(Name="Reference", EmitDefaultValue=false)]
        public string Reference { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class TransactionDataDto {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  RobotIdentifier: ").Append(RobotIdentifier).Append("\n");
            sb.Append("  SpecificContent: ").Append(SpecificContent).Append("\n");
            sb.Append("  DeferDate: ").Append(DeferDate).Append("\n");
            sb.Append("  DueDate: ").Append(DueDate).Append("\n");
            sb.Append("  Reference: ").Append(Reference).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TransactionDataDto);
        }

        /// <summary>
        /// Returns true if TransactionDataDto instances are equal
        /// </summary>
        /// <param name="input">Instance of TransactionDataDto to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TransactionDataDto input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.RobotIdentifier == input.RobotIdentifier ||
                    (this.RobotIdentifier != null &&
                    this.RobotIdentifier.Equals(input.RobotIdentifier))
                ) && 
                (
                    this.SpecificContent == input.SpecificContent ||
                    this.SpecificContent != null &&
                    this.SpecificContent.SequenceEqual(input.SpecificContent)
                ) && 
                (
                    this.DeferDate == input.DeferDate ||
                    (this.DeferDate != null &&
                    this.DeferDate.Equals(input.DeferDate))
                ) && 
                (
                    this.DueDate == input.DueDate ||
                    (this.DueDate != null &&
                    this.DueDate.Equals(input.DueDate))
                ) && 
                (
                    this.Reference == input.Reference ||
                    (this.Reference != null &&
                    this.Reference.Equals(input.Reference))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.RobotIdentifier != null)
                    hashCode = hashCode * 59 + this.RobotIdentifier.GetHashCode();
                if (this.SpecificContent != null)
                    hashCode = hashCode * 59 + this.SpecificContent.GetHashCode();
                if (this.DeferDate != null)
                    hashCode = hashCode * 59 + this.DeferDate.GetHashCode();
                if (this.DueDate != null)
                    hashCode = hashCode * 59 + this.DueDate.GetHashCode();
                if (this.Reference != null)
                    hashCode = hashCode * 59 + this.Reference.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// Property changed event handler
        /// </summary>
        public event PropertyChangedEventHandler PropertyChanged;

        /// <summary>
        /// Trigger when a property changed
        /// </summary>
        /// <param name="propertyName">Property Name</param>
        public virtual void OnPropertyChanged(string propertyName)
        {
            // NOTE: property changed is handled via "code weaving" using Fody.
            // Properties with setters are modified at compile time to notify of changes.
            var propertyChanged = PropertyChanged;
            if (propertyChanged != null)
            {
                propertyChanged(this, new PropertyChangedEventArgs(propertyName));
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Reference (string) maxLength
            if(this.Reference != null && this.Reference.Length > 128)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Reference, length must be less than 128.", new [] { "Reference" });
            }

            // Reference (string) minLength
            if(this.Reference != null && this.Reference.Length < 0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Reference, length must be greater than 0.", new [] { "Reference" });
            }

            yield break;
        }
    }

}
